import typing

from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gio
T = typing.TypeVar("T")

MAJOR_VERSION: int = 1
MICRO_VERSION: int = 6
MINOR_VERSION: int = 6
VERSION_S: str = "1.6.6"
_namespace: str = "Json"
_version: str = "1.0"

def boxed_can_deserialize(gboxed_type: typing.Type[typing.Any], node_type: NodeType) -> bool: ...
def boxed_can_serialize(gboxed_type: typing.Type[typing.Any]) -> typing.Tuple[bool, NodeType]: ...
def boxed_deserialize(gboxed_type: typing.Type[typing.Any], node: Node) -> None: ...
def boxed_serialize(gboxed_type: typing.Type[typing.Any], boxed: None) -> typing.Optional[Node]: ...
def construct_gobject(gtype: typing.Type[typing.Any], data: str, length: int) -> typing.Optional[GObject.Object]: ...
def from_string(str: str) -> typing.Optional[Node]: ...
def gobject_deserialize(gtype: typing.Type[typing.Any], node: Node) -> GObject.Object: ...
def gobject_from_data(gtype: typing.Type[typing.Any], data: str, length: int) -> typing.Optional[GObject.Object]: ...
def gobject_serialize(gobject: GObject.Object) -> Node: ...
def gobject_to_data(gobject: GObject.Object) -> typing.Tuple[str, int]: ...
def gvariant_deserialize(json_node: Node, signature: typing.Optional[str] = None) -> typing.Optional[GLib.Variant]: ...
def gvariant_deserialize_data(json: str, length: int, signature: typing.Optional[str] = None) -> typing.Optional[GLib.Variant]: ...
def gvariant_serialize(variant: GLib.Variant) -> Node: ...
def gvariant_serialize_data(variant: GLib.Variant) -> typing.Tuple[str, int]: ...
def parser_error_quark() -> int: ...
def path_error_quark() -> int: ...
def reader_error_quark() -> int: ...
def serialize_gobject(gobject: GObject.Object) -> typing.Tuple[str, int]: ...
def string_compare(a: str, b: str) -> int: ...
def string_equal(a: str, b: str) -> bool: ...
def string_hash(key: str) -> int: ...
def to_string(node: Node, pretty: bool) -> str: ...

class Array(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> Json.Array
        sized_new(n_elements:int) -> Json.Array
    """
    def add_array_element(self, value: typing.Optional[Array] = None) -> None: ...
    def add_boolean_element(self, value: bool) -> None: ...
    def add_double_element(self, value: float) -> None: ...
    def add_element(self, node: Node) -> None: ...
    def add_int_element(self, value: int) -> None: ...
    def add_null_element(self) -> None: ...
    def add_object_element(self, value: typing.Optional[Object] = None) -> None: ...
    def add_string_element(self, value: str) -> None: ...
    def dup_element(self, index_: int) -> Node: ...
    def equal(self, b: Array) -> bool: ...
    def foreach_element(self, func: typing.Callable[..., None], *data: typing.Any) -> None: ...
    def get_array_element(self, index_: int) -> Array: ...
    def get_boolean_element(self, index_: int) -> bool: ...
    def get_double_element(self, index_: int) -> float: ...
    def get_element(self, index_: int) -> Node: ...
    def get_elements(self) -> typing.Optional[list[Node]]: ...
    def get_int_element(self, index_: int) -> int: ...
    def get_length(self) -> int: ...
    def get_null_element(self, index_: int) -> bool: ...
    def get_object_element(self, index_: int) -> Object: ...
    def get_string_element(self, index_: int) -> str: ...
    def hash(self) -> int: ...
    def is_immutable(self) -> bool: ...
    @classmethod
    def new(cls) -> Array: ...
    def ref(self) -> Array: ...
    def remove_element(self, index_: int) -> None: ...
    def seal(self) -> None: ...
    @classmethod
    def sized_new(cls, n_elements: int) -> Array: ...
    def unref(self) -> None: ...
    

class Builder(GObject.Object):
    """
    :Constructors:

    ::

        Builder(**properties)
        new() -> Json.Builder
        new_immutable() -> Json.Builder

    Object JsonBuilder

    Properties from JsonBuilder:
      immutable -> gboolean: Immutable Output
        Whether the builder output is immutable.

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        immutable: bool
    props: Props = ...
    parent_instance: GObject.Object = ...
    priv: BuilderPrivate = ...
    def __init__(self, immutable: bool = ...) -> None: ...
    def add_boolean_value(self, value: bool) -> typing.Optional[Builder]: ...
    def add_double_value(self, value: float) -> typing.Optional[Builder]: ...
    def add_int_value(self, value: int) -> typing.Optional[Builder]: ...
    def add_null_value(self) -> typing.Optional[Builder]: ...
    def add_string_value(self, value: str) -> typing.Optional[Builder]: ...
    def add_value(self, node: Node) -> typing.Optional[Builder]: ...
    def begin_array(self) -> typing.Optional[Builder]: ...
    def begin_object(self) -> typing.Optional[Builder]: ...
    def end_array(self) -> typing.Optional[Builder]: ...
    def end_object(self) -> typing.Optional[Builder]: ...
    def get_root(self) -> typing.Optional[Node]: ...
    @classmethod
    def new(cls) -> Builder: ...
    @classmethod
    def new_immutable(cls) -> Builder: ...
    def reset(self) -> None: ...
    def set_member_name(self, member_name: str) -> typing.Optional[Builder]: ...
    

class BuilderClass(GObject.GPointer):
    """
    :Constructors:

    ::

        BuilderClass()
    """
    parent_class: GObject.ObjectClass = ...
    _json_reserved1: None = ...
    _json_reserved2: None = ...

class BuilderPrivate(GObject.GPointer): ...

class Generator(GObject.Object):
    """
    :Constructors:

    ::

        Generator(**properties)
        new() -> Json.Generator

    Object JsonGenerator

    Properties from JsonGenerator:
      pretty -> gboolean: Pretty
        Pretty-print the output
      indent -> guint: Indent
        Number of indentation spaces
      root -> JsonNode: Root
        Root of the JSON data tree
      indent-char -> guint: Indent Char
        Character that should be used when indenting

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        indent: int
        indent_char: int
        pretty: bool
        root: Node
    props: Props = ...
    parent_instance: GObject.Object = ...
    priv: GeneratorPrivate = ...
    def __init__(self, indent: typing.Optional[int] = ...,
                 indent_char: typing.Optional[int] = ...,
                 pretty: typing.Optional[bool] = ...,
                 root: typing.Optional[Node] = ...) -> None: ...
    def get_indent(self) -> int: ...
    def get_indent_char(self) -> str: ...
    def get_pretty(self) -> bool: ...
    def get_root(self) -> typing.Optional[Node]: ...
    @classmethod
    def new(cls) -> Generator: ...
    def set_indent(self, indent_level: int) -> None: ...
    def set_indent_char(self, indent_char: str) -> None: ...
    def set_pretty(self, is_pretty: bool) -> None: ...
    def set_root(self, node: Node) -> None: ...
    def to_data(self) -> typing.Tuple[str, int]: ...
    def to_file(self, filename: str) -> bool: ...
    def to_gstring(self, string: GLib.String) -> GLib.String: ...
    def to_stream(self, stream: Gio.OutputStream, cancellable: typing.Optional[Gio.Cancellable] = None) -> bool: ...
    

class GeneratorClass(GObject.GPointer):
    """
    :Constructors:

    ::

        GeneratorClass()
    """
    parent_class: GObject.ObjectClass = ...
    _json_reserved1: None = ...
    _json_reserved2: None = ...
    _json_reserved3: None = ...
    _json_reserved4: None = ...

class GeneratorPrivate(GObject.GPointer): ...

class Node(GObject.GBoxed):
    """
    :Constructors:

    ::

        alloc() -> Json.Node
        new(type:Json.NodeType) -> Json.Node
    """
    @classmethod
    def alloc(cls) -> Node: ...
    def copy(self) -> Node: ...
    def dup_array(self) -> typing.Optional[Array]: ...
    def dup_object(self) -> typing.Optional[Object]: ...
    def dup_string(self) -> typing.Optional[str]: ...
    def equal(self, b: Node) -> bool: ...
    def free(self) -> None: ...
    def get_array(self) -> typing.Optional[Array]: ...
    def get_boolean(self) -> bool: ...
    def get_double(self) -> float: ...
    def get_int(self) -> int: ...
    def get_node_type(self) -> NodeType: ...
    def get_object(self) -> typing.Optional[Object]: ...
    def get_parent(self) -> typing.Optional[Node]: ...
    def get_string(self) -> typing.Optional[str]: ...
    def get_value(self) -> typing.Any: ...
    def get_value_type(self) -> typing.Type[typing.Any]: ...
    def hash(self) -> int: ...
    def init(self, type: NodeType) -> Node: ...
    def init_array(self, array: typing.Optional[Array] = None) -> Node: ...
    def init_boolean(self, value: bool) -> Node: ...
    def init_double(self, value: float) -> Node: ...
    def init_int(self, value: int) -> Node: ...
    def init_null(self) -> Node: ...
    def init_object(self, object: typing.Optional[Object] = None) -> Node: ...
    def init_string(self, value: typing.Optional[str] = None) -> Node: ...
    def is_immutable(self) -> bool: ...
    def is_null(self) -> bool: ...
    @classmethod
    def new(cls, type: NodeType) -> Node: ...
    def ref(self) -> Node: ...
    def seal(self) -> None: ...
    def set_array(self, array: Array) -> None: ...
    def set_boolean(self, value: bool) -> None: ...
    def set_double(self, value: float) -> None: ...
    def set_int(self, value: int) -> None: ...
    def set_object(self, object: typing.Optional[Object] = None) -> None: ...
    def set_parent(self, parent: typing.Optional[Node] = None) -> None: ...
    def set_string(self, value: str) -> None: ...
    def set_value(self, value: typing.Any) -> None: ...
    def take_array(self, array: Array) -> None: ...
    def take_object(self, object: Object) -> None: ...
    def type_name(self) -> str: ...
    def unref(self) -> None: ...
    

class Object(GObject.GBoxed):
    """
    :Constructors:

    ::

        new() -> Json.Object
    """
    def add_member(self, member_name: str, node: Node) -> None: ...
    def dup_member(self, member_name: str) -> typing.Optional[Node]: ...
    def equal(self, b: Object) -> bool: ...
    def foreach_member(self, func: typing.Callable[..., None], *data: typing.Any) -> None: ...
    def get_array_member(self, member_name: str) -> typing.Optional[Array]: ...
    def get_boolean_member(self, member_name: str) -> bool: ...
    def get_boolean_member_with_default(self, member_name: str, default_value: bool) -> bool: ...
    def get_double_member(self, member_name: str) -> float: ...
    def get_double_member_with_default(self, member_name: str, default_value: float) -> float: ...
    def get_int_member(self, member_name: str) -> int: ...
    def get_int_member_with_default(self, member_name: str, default_value: int) -> int: ...
    def get_member(self, member_name: str) -> typing.Optional[Node]: ...
    def get_members(self) -> typing.Optional[list[str]]: ...
    def get_null_member(self, member_name: str) -> bool: ...
    def get_object_member(self, member_name: str) -> typing.Optional[Object]: ...
    def get_size(self) -> int: ...
    def get_string_member(self, member_name: str) -> str: ...
    def get_string_member_with_default(self, member_name: str, default_value: str) -> str: ...
    def get_values(self) -> typing.Optional[list[Node]]: ...
    def has_member(self, member_name: str) -> bool: ...
    def hash(self) -> int: ...
    def is_immutable(self) -> bool: ...
    @classmethod
    def new(cls) -> Object: ...
    def ref(self) -> Object: ...
    def remove_member(self, member_name: str) -> None: ...
    def seal(self) -> None: ...
    def set_array_member(self, member_name: str, value: Array) -> None: ...
    def set_boolean_member(self, member_name: str, value: bool) -> None: ...
    def set_double_member(self, member_name: str, value: float) -> None: ...
    def set_int_member(self, member_name: str, value: int) -> None: ...
    def set_member(self, member_name: str, node: Node) -> None: ...
    def set_null_member(self, member_name: str) -> None: ...
    def set_object_member(self, member_name: str, value: Object) -> None: ...
    def set_string_member(self, member_name: str, value: str) -> None: ...
    def unref(self) -> None: ...
    

class ObjectIter(GObject.GPointer):
    """
    :Constructors:

    ::

        ObjectIter()
    """
    priv_pointer: list[None] = ...
    priv_int: list[int] = ...
    priv_boolean: list[bool] = ...
    def init(self, object: Object) -> None: ...
    def init_ordered(self, object: Object) -> None: ...
    def next(self) -> typing.Tuple[bool, str, Node]: ...
    def next_ordered(self) -> typing.Tuple[bool, str, Node]: ...
    

class Parser(GObject.Object):
    """
    :Constructors:

    ::

        Parser(**properties)
        new() -> Json.Parser
        new_immutable() -> Json.Parser

    Object JsonParser

    Signals from JsonParser:
      parse-start ()
      parse-end ()
      object-start ()
      object-member (JsonObject, gchararray)
      object-end (JsonObject)
      array-start ()
      array-element (JsonArray, gint)
      array-end (JsonArray)
      error (gpointer)

    Properties from JsonParser:
      immutable -> gboolean: Immutable Output
        Whether the parser output is immutable.

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        immutable: bool
    props: Props = ...
    parent_instance: GObject.Object = ...
    priv: ParserPrivate = ...
    def __init__(self, immutable: bool = ...) -> None: ...
    def do_array_element(self, array: Array, index_: int) -> None: ...
    def do_array_end(self, array: Array) -> None: ...
    def do_array_start(self) -> None: ...
    def do_error(self, error: GLib.Error) -> None: ...
    def do_object_end(self, object: Object) -> None: ...
    def do_object_member(self, object: Object, member_name: str) -> None: ...
    def do_object_start(self) -> None: ...
    def do_parse_end(self) -> None: ...
    def do_parse_start(self) -> None: ...
    def get_current_line(self) -> int: ...
    def get_current_pos(self) -> int: ...
    def get_root(self) -> typing.Optional[Node]: ...
    def has_assignment(self) -> typing.Tuple[bool, str]: ...
    def load_from_data(self, data: str, length: int) -> bool: ...
    def load_from_file(self, filename: str) -> bool: ...
    def load_from_mapped_file(self, filename: str) -> bool: ...
    def load_from_stream(self, stream: Gio.InputStream, cancellable: typing.Optional[Gio.Cancellable] = None) -> bool: ...
    def load_from_stream_async(self, stream: Gio.InputStream, cancellable: typing.Optional[Gio.Cancellable] = None, callback: typing.Optional[typing.Callable[..., None]] = None, *user_data: typing.Any) -> None: ...
    def load_from_stream_finish(self, result: Gio.AsyncResult) -> bool: ...
    @classmethod
    def new(cls) -> Parser: ...
    @classmethod
    def new_immutable(cls) -> Parser: ...
    def steal_root(self) -> typing.Optional[Node]: ...
    

class ParserClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ParserClass()
    """
    parent_class: GObject.ObjectClass = ...
    parse_start: typing.Callable[[Parser], None] = ...
    object_start: typing.Callable[[Parser], None] = ...
    object_member: typing.Callable[[Parser, Object, str], None] = ...
    object_end: typing.Callable[[Parser, Object], None] = ...
    array_start: typing.Callable[[Parser], None] = ...
    array_element: typing.Callable[[Parser, Array, int], None] = ...
    array_end: typing.Callable[[Parser, Array], None] = ...
    parse_end: typing.Callable[[Parser], None] = ...
    error: typing.Callable[[Parser, GLib.Error], None] = ...
    _json_reserved1: None = ...
    _json_reserved2: None = ...
    _json_reserved3: None = ...
    _json_reserved4: None = ...
    _json_reserved5: None = ...
    _json_reserved6: None = ...
    _json_reserved7: None = ...
    _json_reserved8: None = ...

class ParserPrivate(GObject.GPointer): ...

class Path(GObject.Object):
    """
    :Constructors:

    ::

        Path(**properties)
        new() -> Json.Path

    Object JsonPath

    Signals from GObject:
      notify (GParam)
    """
    def compile(self, expression: str) -> bool: ...
    def match(self, root: Node) -> Node: ...
    @classmethod
    def new(cls) -> Path: ...
    @staticmethod
    def query(expression: str, root: Node) -> Node: ...
    

class PathClass(GObject.GPointer): ...

class Reader(GObject.Object):
    """
    :Constructors:

    ::

        Reader(**properties)
        new(node:Json.Node=None) -> Json.Reader

    Object JsonReader

    Properties from JsonReader:
      root -> JsonNode: Root Node
        The root of the tree to read

    Signals from GObject:
      notify (GParam)
    """
    class Props:
        root: Node
    props: Props = ...
    parent_instance: GObject.Object = ...
    priv: ReaderPrivate = ...
    def __init__(self, root: typing.Optional[Node] = ...) -> None: ...
    def count_elements(self) -> int: ...
    def count_members(self) -> int: ...
    def end_element(self) -> None: ...
    def end_member(self) -> None: ...
    def get_boolean_value(self) -> bool: ...
    def get_double_value(self) -> float: ...
    def get_error(self) -> typing.Optional[GLib.Error]: ...
    def get_int_value(self) -> int: ...
    def get_member_name(self) -> typing.Optional[str]: ...
    def get_null_value(self) -> bool: ...
    def get_string_value(self) -> str: ...
    def get_value(self) -> typing.Optional[Node]: ...
    def is_array(self) -> bool: ...
    def is_object(self) -> bool: ...
    def is_value(self) -> bool: ...
    def list_members(self) -> list[str]: ...
    @classmethod
    def new(cls, node: typing.Optional[Node] = None) -> Reader: ...
    def read_element(self, index_: int) -> bool: ...
    def read_member(self, member_name: str) -> bool: ...
    def set_root(self, root: typing.Optional[Node] = None) -> None: ...
    

class ReaderClass(GObject.GPointer):
    """
    :Constructors:

    ::

        ReaderClass()
    """
    parent_class: GObject.ObjectClass = ...
    _json_padding0: None = ...
    _json_padding1: None = ...
    _json_padding2: None = ...
    _json_padding3: None = ...
    _json_padding4: None = ...

class ReaderPrivate(GObject.GPointer): ...

class Serializable(GObject.GInterface):
    """
    Interface JsonSerializable

    Signals from GObject:
      notify (GParam)
    """
    def default_deserialize_property(self, property_name: str, value: typing.Any, pspec: GObject.ParamSpec, property_node: Node) -> bool: ...
    def default_serialize_property(self, property_name: str, value: typing.Any, pspec: GObject.ParamSpec) -> typing.Optional[Node]: ...
    def deserialize_property(self, property_name: str, pspec: GObject.ParamSpec, property_node: Node) -> typing.Tuple[bool, typing.Any]: ...
    def find_property(self, name: str) -> typing.Optional[GObject.ParamSpec]: ...
    def get_property(self, pspec: GObject.ParamSpec) -> typing.Any: ...
    def list_properties(self) -> list[GObject.ParamSpec]: ...
    def serialize_property(self, property_name: str, value: typing.Any, pspec: GObject.ParamSpec) -> Node: ...
    def set_property(self, pspec: GObject.ParamSpec, value: typing.Any) -> None: ...
    

class SerializableIface(GObject.GPointer):
    """
    :Constructors:

    ::

        SerializableIface()
    """
    g_iface: GObject.TypeInterface = ...
    serialize_property: typing.Callable[[Serializable, str, typing.Any, GObject.ParamSpec], Node] = ...
    deserialize_property: typing.Callable[[Serializable, str, GObject.ParamSpec, Node], typing.Tuple[bool, typing.Any]] = ...
    find_property: typing.Callable[[Serializable, str], typing.Optional[GObject.ParamSpec]] = ...
    list_properties: None = ...
    set_property: typing.Callable[[Serializable, GObject.ParamSpec, typing.Any], None] = ...
    get_property: typing.Callable[[Serializable, GObject.ParamSpec], typing.Any] = ...

class NodeType(GObject.GEnum):
    ARRAY = 1
    NULL = 3
    OBJECT = 0
    VALUE = 2

class ParserError(GObject.GEnum):
    EMPTY_MEMBER_NAME = 5
    INVALID_BAREWORD = 4
    INVALID_DATA = 6
    MISSING_COLON = 3
    MISSING_COMMA = 2
    PARSE = 0
    TRAILING_COMMA = 1
    UNKNOWN = 7
    @staticmethod
    def quark() -> int: ...

class PathError(GObject.GEnum):
    QUERY = 0
    @staticmethod
    def quark() -> int: ...

class ReaderError(GObject.GEnum):
    INVALID_INDEX = 1
    INVALID_MEMBER = 3
    INVALID_NODE = 4
    INVALID_TYPE = 6
    NO_ARRAY = 0
    NO_OBJECT = 2
    NO_VALUE = 5
    @staticmethod
    def quark() -> int: ...

